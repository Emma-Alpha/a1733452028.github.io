{"posts":[{"title":"前端虚拟滚动列表推荐","content":"https://virtuoso.dev/ 炒鸡好用！！！！！！ ","link":"https://a1733452028.github.io/post/qian-duan-xu-ni-gun-dong-lie-biao-tui-jian/"},{"title":"webpack5配置过程","content":"[TOC] 一、概念 从本质上讲，webpack是现代 JavaScript 应用程序的静态模块打包器。当 webpack 处理您的应用程序时，它会在内部从一个或多个入口点构建一个依赖关系图，然后将您项目所需的每个模块组合成一个或多个bundles，这些 bundles 是用于提供内容的静态资产。 二、入口 在某个文件中创建名为webpack5的文件夹, 然后执行package.json初始化命令（全程回车） mkdir webpack5 &amp;&amp; cd webpack5 yarn init 创建名为config的文件夹（用于存放webpack5的配置文件） mkdir config 主要存放三个文件: webpack 公共资源部分，webpack dev开发环境部分, webpack build 打包环境部分 cd config # 创建webpack 公共资源部分 touch webpack.public.js # webpack dev开发环境部分 touch webpack.development.js # webpack build 打包环境部分 touch webpack.product.js 创建webpack入口文件, 入口文件存放到根目录的src里面。而src目录不存在，需要我们创建 cd .. &amp;&amp; mkdir src cd src &amp;&amp; touch index.js 完成以上创建文件以及文件夹准备工作之后，需要安装webpack。(以下附上当前代码的目录结构, node_modules和 yarn-error.log可以忽略) 三、安装 回到项目的根目录，我们需要安装webpack以及webpack-cli cd .. yarn add webpack webpack-cli -D 出现以下截图即代表安装成功 四、使用React+JavaScript React yarn add react react-dom -D 安装成功后，目前项目是无法识别的React语法jsx的内容，因此需要在webpack.public.js中添加匹配规则，告诉webpack遇到这个文件我们应该使用什么解析器去解读这类文件，webpack5中使用babel-loader是可以完成的，但本次文档中使用esbuild-loader来进行编译。（具体原因：esbuild-loader是使用go进行编译的，而babel-loader是调用JavasScript进行编译的，从语言的角度上来说，Go是比JavaScript快的，因此esbuild-loader编译出来的速度是比babel-loader快）esbuild-loader的详细介绍点击这里 yarn add esbuild-loader -D 在config文件夹中新创建一个paths.js文件(用于封装路径方法) cd config &amp;&amp; touch paths.js paths.js的内容 const fs = require('fs') const path = require('path') const appDirectory = fs.realpathSync(process.cwd()); const resolveApp = relativePath =&gt; path.resolve(appDirectory, relativePath); module.exports = { resolveApp } 添加webpack入口文件 编写webpack.public.js 文件 const path = require(&quot;./paths.js&quot;) module.exports = { entry: [ path.resolveApp(&quot;src/index.js&quot;) ] } 编写webpack输出文件，而开发环境中是需要追求构建效率，因此需要缓存策略来加快；而线上却需要更新完后，用户能够立马看到效果。因此需要contenthash来进行区分。 针对线上和开发环境中可能出现的两种不同情况来考虑，我们需要通过合并公共部分，然后定义不同的规则来实现，因此webpack-merge很符合我们的需求。webpack-merge的详细说明 yarn add webpack-merge -D 修改webpack.development.js的内容 const common = require(&quot;./webpack.public.js&quot;) const {merge} = require(&quot;webpack-merge&quot;) const path = require(&quot;./paths.js&quot;) module.exports = merge(common, { mode: &quot;development&quot;, output: { filename: &quot;[name].bundle.js&quot;, clean: true, path: path.resolveApp(&quot;dist&quot;) } }) 修改webpack.product.js const common = require(&quot;./webpack.public.js&quot;) const {merge} = require(&quot;webpack-merge&quot;) const path = require(&quot;./paths.js&quot;) module.exports = merge(common, { mode: &quot;production&quot;, output: { filename: &quot;[name].[contenthash].bundle.js&quot;, clean: true, path: path.resolveApp(&quot;dist&quot;) } }) 编写Webpack 匹配jsx,js的规则，由于开发环境和生成环境无需做区分，因此在webpack.public.js中进行编写 const path = require(&quot;./paths.js&quot;) module.exports = { entry: [ path.resolveApp(&quot;src/index.js&quot;) ], module: { rules: [{ test: /\\.(js|jsx)$/, include: [path.resolveApp(&quot;src&quot;)], exclude: [path.resolveApp(&quot;node_modules&quot;)], user: [ { loader: &quot;babel-loader&quot; } ] }] } } 细心的朋友可能会发现，代码中是没有使用esbuild-loader,而是使用了babel-loader。这次更替的原因是babel-loader可以支持很多很好用的插件，比如问号表达式，antd按需导入css等等。esbuild-loader目前是没有支持以上的插件，因此需要使用babel-loader yarn add babel-loader -D 在config文件夹下创建babel.config.js文件 touch babel.config.js babel.config.js文件的内容 module.exports = { presets: [ [&quot;@babel/preset-env&quot;, { // 配置packages.json的browserlist针对指定浏览器版本做适配 useBuiltIns: false, modules: false }], &quot;@babel/preset-react&quot; // 将React代码转换成es5 ], plugins: [ [&quot;@babel/plugin-transform-runtime&quot;, { // 转译代码 &quot;corejs&quot;: 3 }], &quot;@babel/plugin-proposal-nullish-coalescing-operator&quot;, // 问号??的用法 &quot;@babel/plugin-proposal-optional-chaining&quot;, // 问号?.的用法 [&quot;@babel/plugin-proposal-decorators&quot;, { legacy: true }], // 解析装饰器 dva中的@connect [&quot;@babel/plugin-proposal-class-properties&quot;, { legacy: true }], // 转换类中某些属性 ** 注意：@babel/plugin-proposal-decorators 和 @babel/plugin-proposal-class-properties要保持这样。 &quot;babel-plugin-inline-react-svg&quot;, // 将svg 导出React组件 [&quot;babel-plugin-import&quot;, { libraryName: 'antd', libraryDirectory: 'es', style: true }], // 导入组件的时候，顺带导入样式 ] } 需要安装一下的包 yarn add @babel/preset-env -D yarn add @babel/preset-react -D yarn add @babel/plugin-transform-runtime -D yarn add @babel/runtime-corejs3 -D yarn add @babel/plugin-proposal-nullish-coalescing-operator -D yarn add @babel/plugin-proposal-optional-chaining -D yarn add @babel/plugin-proposal-decorators -D yarn add @babel/plugin-proposal-class-properties -D yarn add babel-plugin-inline-react-svg -D yarn add babel-plugin-import -D yarn add @babel/core -D 安装完成后，修改一下webpack.public.js的babel-loader规则 const path = require(&quot;./paths.js&quot;) const babelOptions = require(&quot;./babel.config.js&quot;) module.exports = { entry: [ path.resolveApp(&quot;./src/index.js&quot;) ], resolve:{ extensions: [&quot;.jsx&quot;, &quot;.js&quot;, &quot;.json&quot;] // 无需后缀即可完成导入 }, module: { rules: [{ test: /\\.(js|jsx)$/, include: [path.resolveApp(&quot;src&quot;)], exclude: [path.resolveApp(&quot;node_modules&quot;)], use: [ { loader: &quot;babel-loader&quot;, options: babelOptions } ] }] } } 我们需要在开发环境中看到效果，因此需要安装webpack-dev-server这个开发服务器。 yarn add webpack-dev-server -D 修改webpack.development.js文件 const common = require(&quot;./webpack.public.js&quot;) const {merge} = require(&quot;webpack-merge&quot;) const path = require(&quot;./paths.js&quot;) module.exports = merge(common, { mode: &quot;development&quot;, output: { filename: &quot;[name].bundle.js&quot;, clean: true, path: path.resolveApp(&quot;dist&quot;) }, devServer: { host: &quot;0.0.0.0&quot;, port: 3000, compress: true, // 开启服务器gzip压缩 open: false, historyApiFallback: true, // 提供页面来替代404响应 hot: &quot;only&quot;, // 构建失败的情况下启动热模块替代而不是刷新页面 } }) 通过node 命令来启动服务器查看效果 修改根目录下的package.json文件 { &quot;name&quot;: &quot;webpack5&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server --config config/webpack.development.js&quot; }, &quot;devDependencies&quot;: { &quot;@babel/core&quot;: &quot;^7.18.5&quot;, &quot;@babel/plugin-proposal-class-properties&quot;: &quot;^7.17.12&quot;, &quot;@babel/plugin-proposal-decorators&quot;: &quot;^7.18.2&quot;, &quot;@babel/plugin-proposal-optional-chaining&quot;: &quot;^7.17.12&quot;, &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.18.5&quot;, &quot;@babel/preset-env&quot;: &quot;^7.18.2&quot;, &quot;@babel/preset-react&quot;: &quot;^7.17.12&quot;, &quot;@babel/runtime-corejs3&quot;: &quot;^7.18.3&quot;, &quot;babel-loader&quot;: &quot;^8.2.5&quot;, &quot;babel-plugin-import&quot;: &quot;^1.13.5&quot;, &quot;babel-plugin-inline-react-svg&quot;: &quot;^2.0.1&quot;, &quot;esbuild-loader&quot;: &quot;^2.19.0&quot;, &quot;react&quot;: &quot;^18.1.0&quot;, &quot;react-dom&quot;: &quot;^18.1.0&quot;, &quot;webpack&quot;: &quot;^5.73.0&quot;, &quot;webpack-cli&quot;: &quot;^4.10.0&quot;, &quot;webpack-dev-server&quot;: &quot;^4.9.2&quot;, &quot;webpack-merge&quot;: &quot;^5.8.0&quot; } } 然后在终端敲 yarn dev 出现以上内容，即为成功。 现在我们访问http://localhost:3000/是没有任何效果的。 因此我们需要对src/index.js进行改造 // index.js import React from &quot;react&quot;; import {createRoot} from &quot;react-dom/client&quot; function HelloMessage({name}){ return &lt;div&gt;Hello {name}&lt;/div&gt; } const root = createRoot( document.getElementById(&quot;root&quot;) ) root.render(&lt;HelloMessage name={&quot;Bob&quot;}/&gt;) 通过之前对React-dom的学习以及了解，解读代码就知道React需要将DOM节点挂载到id=&quot;root&quot;的元素上。 因此，我们需要一个html的模板，进入src目录中 -&gt; pwd /Users/liangpingbo/Desktop/个人/前端/webpack/webpack5 cd src touch index.html index.html的内容如下 &lt;!doctype html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;!-- &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt; --&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt; &lt;title&gt;&lt;%= htmlWebpackPlugin.options.title %&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;&lt;%= htmlWebpackPlugin.options.mountRoot %&gt;&quot; style=&quot;height: 100%;&quot;&gt;&lt;/div&gt; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 仔细观察，就会发现id 并没有写死，而是通过一个插件进行动态传递的。 这时我们就需要安装一个插件 yarn add --dev html-webpack-plugin 我们需要对webpack.public.js的内容进行修改 const path = require(&quot;./paths.js&quot;) const babelOptions = require(&quot;./babel.config.js&quot;) const HtmlWebpackPlugin = require('html-webpack-plugin') module.exports = { entry: [ path.resolveApp(&quot;./src/index.js&quot;) ], resolve: { extensions: [&quot;.jsx&quot;, &quot;.js&quot;, &quot;.json&quot;] // 无需后缀即可完成导入 }, module: { rules: [{ test: /\\.(js|jsx)$/, include: [path.resolveApp(&quot;src&quot;)], exclude: [path.resolveApp(&quot;node_modules&quot;)], use: [{ loader: &quot;babel-loader&quot;, options: babelOptions }] }] }, plugins: [ new HtmlWebpackPlugin({ title: &quot;webpack5演示demo&quot;, mountRoot: &quot;root&quot;, template: path.resolveApp(&quot;./src/index.html&quot;), filename: &quot;index.html&quot;, inject: 'body', // 所有javascript 资源都是加载到body底部 htmlContent: '&lt;%- __html__ %&gt;', initialData: 'window.__INITIAL_STATE__ = &lt;%- __state__ %&gt;', hash: true, // 为静态资源生成hash值 minify: { // 压缩HTML文件 removeComments: false, // 移除HTML中的注释 collapseWhitespace: false, // 删除空白符与换行符 }, }) ] } 再次启动开发服务器 yarn dev 通过浏览器访问localhost:3000，就会发现出现hello Bob 五、优化Webpack 进度条 由于启动Webpack 时，常常输出一堆太感兴趣的东西。因此，需要一个工具将其美化一下(webpackbar) yarn add webpackbar -D 修改webpack.public.js的内容 const path = require(&quot;./paths.js&quot;) const babelOptions = require(&quot;./babel.config.js&quot;) const HtmlWebpackPlugin = require('html-webpack-plugin') const WebpackBar = require('webpackbar'); console.log(path.resolveApp(&quot;./src/index.html&quot;),) module.exports = { entry: [ path.resolveApp(&quot;./src/index.js&quot;) ], resolve: { extensions: [&quot;.jsx&quot;, &quot;.js&quot;, &quot;.json&quot;] // 无需后缀即可完成导入 }, module: { rules: [{ test: /\\.(js|jsx)$/, include: [path.resolveApp(&quot;src&quot;)], exclude: [path.resolveApp(&quot;node_modules&quot;)], use: [{ loader: &quot;babel-loader&quot;, options: babelOptions }] }] }, plugins: [ new WebpackBar(), new HtmlWebpackPlugin({ title: &quot;webpack5演示demo&quot;, mountRoot: &quot;root&quot;, template: path.resolveApp(&quot;./src/index.html&quot;), filename: &quot;index.html&quot;, inject: 'body', // 所有javascript 资源都是加载到body底部 htmlContent: '&lt;%- __html__ %&gt;', initialData: 'window.__INITIAL_STATE__ = &lt;%- __state__ %&gt;', hash: true, // 为静态资源生成hash值 minify: { // 压缩HTML文件 removeComments: false, // 移除HTML中的注释 collapseWhitespace: false, // 删除空白符与换行符 }, }) ] } 六、使用Antd 首先安装antd yarn add antd -D 修改src/index.js import React from &quot;react&quot;; import { createRoot } from &quot;react-dom/client&quot; import { Button } from &quot;antd&quot;; function HelloMessage({ name }) { return &lt;div&gt; Hello {name} &lt;div&gt; &lt;Button&gt;测试&lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; } const root = createRoot( document.getElementById(&quot;root&quot;) ) root.render(&lt;HelloMessage name={&quot;Bob&quot;} /&gt;) 这时启动yarn dev，就会出现一个报错。 由于我们webpack没有对less指定loader解析，因此遇到less会报错。 开发环境和生产环境上，对less解析有所不同。 webpack.development.js const common = require(&quot;./webpack.public.js&quot;) const { merge } = require(&quot;webpack-merge&quot;) const path = require(&quot;./paths.js&quot;) module.exports = merge(common, { mode: &quot;development&quot;, output: { filename: &quot;[name].bundle.js&quot;, clean: true, path: path.resolveApp(&quot;dist&quot;), publicPath: &quot;/&quot; }, devServer: { host: &quot;0.0.0.0&quot;, port: 3000, compress: true, // 开启服务器gzip压缩 open: false, historyApiFallback: true, // 提供页面来替代404响应 hot: &quot;only&quot;, // 构建失败的情况下启动热模块替代而不是刷新页面 }, module: { rules: [{ test: /\\.less$/, include: [/[\\\\/]node_modules[\\\\/].*antd/], use: [{ loader: &quot;style-loader&quot; }, { loader: &quot;css-loader&quot;, options: { sourceMap: true, } }, { loader: &quot;less-loader&quot;, options: { sourceMap: true, lessOptions: { javascriptEnabled: true, } } } ] }] } }) 需要安装loader yarn add style-loader -D yarn add css-loader -D yarn add less-loader -D yarn add less -D 完成以上操作，启动项目看看。 看到效果了，代表less规则生效。 webpack.product.js const common = require(&quot;./webpack.public.js&quot;) const { merge } = require(&quot;webpack-merge&quot;) const path = require(&quot;./paths.js&quot;) const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;); const CssMinimizerPlugin = require(&quot;css-minimizer-webpack-plugin&quot;); module.exports = merge(common, { mode: &quot;production&quot;, output: { filename: &quot;[name].[contenthash].bundle.js&quot;, clean: true, path: path.resolveApp(&quot;dist&quot;) }, module: { rules: [{ test: /\\.less$/, include: [/[\\\\/]node_modules[\\\\/].*antd/], use: [{ loader: MiniCssExtractPlugin.loader, }, { loader: &quot;css-loader&quot;, options: { sourceMap: true, } }, { loader: &quot;less-loader&quot;, options: { sourceMap: true, lessOptions: { javascriptEnabled: true, } } } ] }] }, plugins: [new MiniCssExtractPlugin({ filename: &quot;[name].[contenthash:8].css&quot;, chunkFilename: &quot;[name].[contenthash:8].chunk.css&quot; })], // 将css 提取到单独文件中，为每个css的js创建一个css文件，并且支持css和SourceMaps按需加载。 optimization: { minimize: true, minimizer: [ new CssMinimizerPlugin({ parallel: true, minimizerOptions: { preset: [ &quot;default&quot;, { discardComments: { removeAll: true }, }, ], }, }), // 用来压缩css文件的 ] } }) 安装依赖 yarn add mini-css-extract-plugin -D yarn add css-minimizer-webpack-plugin -D 七、根据需求安装loader 1. css 如果项目中引用了css文件，而此时Webpack匹配规则并没有css解析器。因此我们需要分别对webpack.development.js 和 webpack.product.js进行添加规则 webpack.development.js const common = require(&quot;./webpack.public.js&quot;) const { merge } = require(&quot;webpack-merge&quot;) const path = require(&quot;./paths.js&quot;) module.exports = merge(common, { mode: &quot;development&quot;, output: { filename: &quot;[name].bundle.js&quot;, clean: true, path: path.resolveApp(&quot;dist&quot;), publicPath: &quot;/&quot; }, devServer: { host: &quot;0.0.0.0&quot;, port: 3000, compress: true, // 开启服务器gzip压缩 open: false, historyApiFallback: true, // 提供页面来替代404响应 hot: &quot;only&quot;, // 构建失败的情况下启动热模块替代而不是刷新页面 }, module: { rules: [{ test: /\\.less$/, include: [/[\\\\/]node_modules[\\\\/].*antd/], use: [{ loader: &quot;style-loader&quot; }, { loader: &quot;css-loader&quot;, options: { sourceMap: true, } }, { loader: &quot;less-loader&quot;, options: { sourceMap: true, lessOptions: { javascriptEnabled: true, } } } ] }, { test: /\\.css$/, include: [path.resolveApp(&quot;src&quot;)], use: [{ loader: &quot;style-loader&quot; }, { loader: &quot;css-loader&quot;, options: { sourceMap: true, } }, ] } ], } }) webpack.product.js const path = require(&quot;./paths.js&quot;) const babelOptions = require(&quot;./babel.config.js&quot;) const HtmlWebpackPlugin = require('html-webpack-plugin') const WebpackBar = require('webpackbar'); console.log(path.resolveApp(&quot;./src/index.html&quot;), ) module.exports = { entry: [ path.resolveApp(&quot;./src/index.js&quot;) ], resolve: { extensions: [&quot;.jsx&quot;, &quot;.js&quot;, &quot;.json&quot;] // 无需后缀即可完成导入 }, module: { rules: [{ test: /\\.(js|jsx)$/, include: [path.resolveApp(&quot;src&quot;)], exclude: [path.resolveApp(&quot;node_modules&quot;)], use: [{ loader: &quot;babel-loader&quot;, options: babelOptions }] }] }, plugins: [ new WebpackBar(), // 进度条 new HtmlWebpackPlugin({ title: &quot;webpack5演示demo&quot;, mountRoot: &quot;root&quot;, template: path.resolveApp(&quot;./src/index.html&quot;), filename: &quot;index.html&quot;, inject: 'body', // 所有javascript 资源都是加载到body底部 htmlContent: '&lt;%- __html__ %&gt;', initialData: 'window.__INITIAL_STATE__ = &lt;%- __state__ %&gt;', hash: true, // 为静态资源生成hash值 minify: { // 压缩HTML文件 removeComments: false, // 移除HTML中的注释 collapseWhitespace: false, // 删除空白符与换行符 }, }) ] } 在src目录下，添加index.css index.css .demo1{ background-color: red; } 修改index.js import React from &quot;react&quot;; import { createRoot } from &quot;react-dom/client&quot; import { Button } from &quot;antd&quot;; import &quot;./index.css&quot; function HelloMessage({ name }) { return &lt;div&gt; Hello {name} &lt;div className={&quot;demo1&quot;}&gt; &lt;Button&gt;测试&lt;/Button&gt; &lt;/div&gt; &lt;/div&gt; } const root = createRoot( document.getElementById(&quot;root&quot;) ) root.render(&lt;HelloMessage name={&quot;Bob&quot;} /&gt;) 出现以下效果，则代表规则匹配上。 2. png, jpeg, gif webpack匹配规则现在无法对png,jpeg,git进行解析，因此我们需要对其添加解析器。 webpack.public.js const path = require(&quot;./paths.js&quot;) const babelOptions = require(&quot;./babel.config.js&quot;) const HtmlWebpackPlugin = require('html-webpack-plugin') const WebpackBar = require('webpackbar'); module.exports = { output: { assetModuleFilename: &quot;images/[hash][ext]&quot;, // 将png,jpg,jpeg,gif等资源文件存放到images下。 }, entry: [ path.resolveApp(&quot;./src/index.js&quot;) ], resolve: { extensions: [&quot;.jsx&quot;, &quot;.js&quot;, &quot;.json&quot;] // 无需后缀即可完成导入 }, module: { rules: [{ test: /\\.(js|jsx)$/, include: [path.resolveApp(&quot;src&quot;)], exclude: [path.resolveApp(&quot;node_modules&quot;)], use: [{ loader: &quot;babel-loader&quot;, options: babelOptions }] }, { test: /\\.(png|jpg|jpeg|gif)$/, type: &quot;asset/resource&quot;, } ] }, plugins: [ new WebpackBar(), // 进度条 new HtmlWebpackPlugin({ title: &quot;webpack5演示demo&quot;, mountRoot: &quot;root&quot;, template: path.resolveApp(&quot;./src/index.html&quot;), filename: &quot;index.html&quot;, inject: 'body', // 所有javascript 资源都是加载到body底部 htmlContent: '&lt;%- __html__ %&gt;', initialData: 'window.__INITIAL_STATE__ = &lt;%- __state__ %&gt;', hash: true, // 为静态资源生成hash值 minify: { // 压缩HTML文件 removeComments: false, // 移除HTML中的注释 collapseWhitespace: false, // 删除空白符与换行符 }, }) ] } 修改src目录下的index.js import React from &quot;react&quot;; import { createRoot } from &quot;react-dom/client&quot; import { Button, Avatar } from &quot;antd&quot;; import &quot;./index.css&quot; import User1 from &quot;./user1.jpeg&quot; function HelloMessage({ name }) { return &lt;div&gt; Hello {name} &lt;div className={&quot;demo1&quot;}&gt; &lt;Button&gt;测试&lt;/Button&gt; &lt;/div&gt; &lt;Avatar src={User1}/&gt; &lt;/div&gt; } const root = createRoot( document.getElementById(&quot;root&quot;) ) root.render(&lt;HelloMessage name={&quot;Bob&quot;} /&gt;) ","link":"https://a1733452028.github.io/post/webpack5-pei-zhi-guo-cheng/"},{"title":"webpack5使用optimize-css-assets-webpack-plugin的坑","content":"HookWebpackError: Cannot read properties of undefined (https://a1733452028.github.io/post-images/1653978441759.jpeg) 首先看到这个报错，我是一脸懵逼的。 但静下心来查看报错，就会发现TypeError 似乎都是发生在于css。 那根据以往经验来判断，要不就是解析css出问题要不就是其他的地方处理css的时候出现问题。 看到错误里面出现了postcss，我一开始以为是css里面使用postcss-loader解析器导致的，后来去Webpack配置文件里面查看，发现并没有使用这个loader解析器。于是我将目光投递到postcss-merge-longhand 然后搜索浏览器，发现一个很有趣的地方，就是他github会调转到cssnao这个库里面。https://www.npmjs.com/package/postcss-merge-longhand 然后，我发现cssnao好像有使用在webpack里面。 发现cssnao 使用在optimize-css-assets-webpack-plugin这个插件里面。 刚好这个插件是处理css的。(用于压缩css)。 去github搜索这个插件，发现已经很久没有更新维护，以及提醒webpack5尽量使用新的插件css-minimizer-webpack-plugin 于是，我将optimize-css-assets-webpack-plugin插件替换成css-minimizer-webpack-plugin 后进行打包，发现并没有出现错误。 出于技术的好奇心，我很想知道到底是什么原因导致了optimize-css-assets-webpack-plugin压缩css的时候出现了问题。通过比较原始的手段来进行排查，后来发现原因就出现在less里面编写了以下内容导致的 border-color: rgba(51, 112, 255, 1); border: 3px solid rgba(51, 112, 255, 1); 一开始怀疑是rgba的原因导致的，后来通过实验得出，并不是rgba的原因导致的。 目前只测试出以上两种写法会导致压缩css出现报错。 ","link":"https://a1733452028.github.io/post/webpack5-shi-yong-optimize-css-assets-webpack-plugin-de-keng/"},{"title":"线上fouc问题分析","content":" 有用户反馈apmbox系统在模块之间来回切换，会有一瞬间样式丢失。首次加载的时候却没有发生丢失的现象 问题分析 由于这个问题是首次遇到，在问题分析上并没有很好的思路。只能见招拆招，由于是子应用之间切换导致样式丢失，这很难让人不对qiankun这个微前端框产生怀疑。于是，产生了很多对qiankun类似的问题分析 子应用切换的时候, 样式没有加载？ 是否是dom界面中的标签 在子应用节点之后，导致样式延后加载 能否将Link标签 调整成子应用dom节点之前，加载css样式的速度 为什么qiankun的样式劫持函数会迟于生命周期 浏览器是否有bug，更换浏览器观察一下？ 探索道路 首先，我们对问题背景进行一波分析，样式丢失是发生在子应用切换期间，应用首次加载的时候没有出现样式丢失。 那排查的问题从子应用切换开始，打开Chrome 浏览器查看。发现css样式的加载是在html的body里面。 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://devapmbox.gz4399.com/slogsearch/467.670e3253.chunk.css&quot;&gt; 如果，想将外部css的样式表添加到我们实际项目中，需要将link的rel 设置成stylesheet。 由于js对dom节点操作，是属于异步js。因此在动态添加Link的时候，请求css样式表是属于异步操作。一旦浏览器css 缓存消失，css就会重新请求。由于浏览器的渲染过程中，js和css 是属于并行操作，但由于js是在本地浏览器，不需要网络开销。因此会导致js生成树已经完成,css生成树并没有完成，两者相结合渲染树，这时的效果是一个没有css样式的组件呈现在页面上。之后,css样式请求完毕，浏览器会重新生成css生成树，然后和js生成树重新结合渲染树。这时浏览器就会呈现出有样式的组件。 因此，根据以上观点。基本可以排除问题分析第二，三点的作用。只要link标签添加到body里面，Link的效果都是异步js的作用，无法阻止浏览器渲染，因此还会出现fouc的现象。问题分析第一点可以排除，子应用在切换的时候，样式表是有加载的，只是加载速度慢于页面呈现的速度，因此会产生fouc的现象。 目前，问题分析中还有第4,5点还没有排除。我先尝试验证一下第五点，下载firefox浏览器测试一下。经过测试，发现firefox无论怎么操作都不会出现fouc,不过测试的时候发现，点击时切换的流畅度是没有谷歌浏览器流畅，因此我猜测是firefox的渲染引擎和chrome浏览器渲染引擎略有不同。**目前还没找到相关的资料，来证明firefox在body标签动态插入link标签与chrome浏览器表现不同。**通过上述的实验，可以证明问题分析第5点成立，确实不同浏览器呈现的效果不同。 为了验证问题分析四，我在qiankun的excludeAssetFilter劫持css样式函数上进行console.log操作，发现qiankun的beforeMount进行console.log的操作，先于excludeAssetFilter。而样式表只能出现excludeAssetFilter上，因此，推断出无法在子应用挂载之前加css样式表追加到head标签里面。除非更改qiankun的沙箱模式。 ","link":"https://a1733452028.github.io/post/xian-shang-fouc-wen-ti-fen-xi/"},{"title":"Webpack打包异常排查思路","content":"一、问题描述 考勤系统在访问某个页面时出现异常的问题 复现地址 二、具体分析 异常页面出现以下的内容：Uncaught (in promise) TypeError: Super expression must either be null or a function 出现以上错误后，我在google上搜索得出的结果大部分都是说我的编写React时语法出现问题。google搜索结果 不过，这个结论很快就被我否决掉。因为本地开发的时候，这个页面是可以正常运行的。 三、排查思路 通过具体分析中，我归纳总结出了大概解决思路： 首先webpack development模式(开发模式)上是不存在任何问题，出现问题是在 production (生产模式) 异常报错 指出我React 语法有问题, 并且报错的文件指向是Js类型的文件。 四、尝试解决问题 有了大概思路，就需要实践一波了。 首先，查看webpack配置文件(这个项目比较特殊，webpack配置文件只存在一份文件) webapck.config.js const path = require('path'); const fs = require('fs'); const webpack = require('webpack'); const HtmlWebpackPlugin = require('html-webpack-plugin'); const AddAssetHtmlPlugin = require('add-asset-html-webpack-plugin'); const CopyWebpackPlugin = require('copy-webpack-plugin'); const merge = require('webpack-merge'); const TerserJSPlugin = require('terser-webpack-plugin'); const MiniCssExtractPlugin = require('mini-css-extract-plugin'); const OptimizeCssAssetsPlugin = require('optimize-css-assets-webpack-plugin'); const lessToJs =require('less-vars-to-js'); const paletteLess = fs.readFileSync('src/styles/variables.less', 'utf8'); const lessVars = lessToJs(paletteLess, {resolveVariables: true, stripPrefix: true}); if(lessVars['font-family']){ lessVars['font-family'] = `&quot;${lessVars['font-family']}&quot;` } const aliyunTheme = require('../node_modules/@ant-design/aliyun-theme').default; module.exports = (env) =&gt; { const isDev = env.mode === 'development'; let config; const base = { mode: isDev ? 'development' : 'production', devtool: 'inline-source-map', context: path.resolve(__dirname, '../'), // 入口这里reat-hot-loader官文说要加上reat-hot-loader、patch，以及下面的react-babel-loader/babel，实测加上会导致开发模式下radiobutton异常，去掉并不影响热加载和浏览器自动刷新，所以不要加了。 entry: ['@babel/polyfill', './src/index.js'], output: { path: path.resolve(__dirname, '../dist'), pathinfo: isDev, filename: isDev ? '[name].js' : '[name].[hash:8].js', publicPath: '/', chunkFilename: isDev ? '[name].chunk.js' : '[name].[hash:8].chunk.js', hotUpdateMainFilename: '[hash].hot-update.json', }, module: { rules: [ // { // enforce: 'pre', // test: /\\.js$|\\.jsx$/, // loader: 'eslint-loader', // include: [path.resolve(__dirname, '../src')], // exclude: [path.resolve(__dirname, '../src/views/components/term_record')], // }, { test: /\\.(js|jsx)$/, include: [path.resolve(__dirname, '../src')], exclude: [path.resolve(__dirname, '../node_modules')], use: [ { loader: 'babel-loader', options: { presets: [ ['@babel/preset-env', { useBuiltIns: false, }], '@babel/preset-react', ], plugins: [ // &quot;@babel/plugin-transform-runtime&quot;, '@babel/plugin-syntax-dynamic-import', ['@babel/plugin-proposal-decorators', { legacy: true }], ['@babel/plugin-proposal-class-properties', { loose: true }], '@babel/plugin-proposal-export-default-from', '@babel/plugin-transform-reserved-words', 'inline-react-svg', ['import', { libraryName: 'antd', style: true }, 'antd'], ['import', { libraryName: 'ant-design-pro', libraryDirectory: 'lib', style: true, camel2DashComponentName: false}, 'ant-design-pro'] ], // This is a feature of `babel-loader` for webpack (not Babel itself). // It enables caching results in ./node_modules/.cache/babel-loader/ // directory for faster rebuilds. cacheDirectory: true, }, }, ], }, { test: /\\.css$/, use: [ isDev ? 'style-loader' : MiniCssExtractPlugin.loader, { loader: 'css-loader', options: { sourceMap: true, }, }, ], }, // 解析未启用css-modules的less文件 { test: /\\.less$/, include: [/[\\\\/]node_modules[\\\\/].*antd/], use: [ isDev ? 'style-loader' : MiniCssExtractPlugin.loader, { loader: 'css-loader', options: { sourceMap: true, }, }, { loader: 'less-loader', options: { sourceMap: true, modifyVars: { ...aliyunTheme, ...lessVars, '@icon-url': '&quot;../../../../../public/fonts/anticon/font_r5u29ls31bgldi&quot;', }, javascriptEnabled: true, }, }, ], }, // 解析启用css-modules的less文件 { test: /\\.less$/, use: [ isDev ? 'style-loader' : MiniCssExtractPlugin.loader, { loader: 'css-loader', options: { modules: true, localIdentName: '[name]__[local]', importLoaders: 2, }, }, { loader: 'less-loader', options: { javascriptEnabled: true, modifyVars: { ...aliyunTheme, ...lessVars, }, }, }, ], include: [path.resolve(__dirname, '../src')], exclude: [path.resolve(__dirname, '../node_modules')], }, // 处理anticon图标字体文件 { resource: path.resolve(__dirname, '../public/fonts/anticon'), use: [ { loader: 'url-loader', options: { name: 'assets/anticon/[name].[ext]' } } ], }, { test: /\\.(png|jpg|gif)$/, use: [ { loader: 'file-loader', options: { name: '[name].[ext]', outputPath: 'images/', // publicPath: 'images/', }, }, ], }, { test: /\\.svg(\\?v=\\d+\\.\\d+\\.\\d+)?$/, use: [ { loader: 'babel-loader', }, { loader: '@svgr/webpack', options: { babel: false, icon: true, }, }, ], } ], }, plugins: [ new HtmlWebpackPlugin({ title: '蓝海系统', template: path.join(__dirname, '../src/index.html'), filename: 'index.html', inject: 'body', htmlContent: '&lt;%- __html__ %&gt;', initialData: 'window.__INITIAL_STATE__ = &lt;%- __state__ %&gt;', hash: true, // 为静态资源生成hash值 minify: { // 压缩HTML文件 removeComments: false, // 移除HTML中的注释 collapseWhitespace: false, // 删除空白符与换行符 }, }), ], resolve: { modules: [ path.resolve(__dirname, '../src'), './node_modules', ], alias: { // 解决rsuite-picker依赖旧版本react导致找不到react/lib/ReactDOM的问题 'react-dom': path.resolve(__dirname, '../node_modules/react-dom'), }, extensions: ['.js', '.jsx', '.json'], }, }; if (isDev) { config = merge(base, { module: { rules: [ // 前端页面性能监控 { test: require.resolve('react-addons-perf'), use: [{ loader: 'expose-loader', options: 'Perf', }], }, ], }, plugins: [ new webpack.HotModuleReplacementPlugin(), // 当接收到热更新信号时，在浏览器console控制台打印更多可读性高的模块名称等信息 new webpack.NamedModulesPlugin(), ], devServer: { compress: true, open: false, host: '0.0.0.0', port: 3011, index: 'src/index.html', publicPath: '/', historyApiFallback: true, // 设为false会导致手动刷新页面（路由有效）时，报404 // 配置热加载,所有配置替代方案：webpack-cli --inline --hot --hot-only inline: true, // 实时刷新 // 注意，必须有 webpack.HotModuleReplacementPlugin 才能完全启用 HMR。如果 webpack 或 webpack-dev-server 是通过 --hot 选项启动的，那么这个插件会被自动添加，所以你可能不需要把它添加到 webpack.config.js 中。 hot: true, // 模块热更新。依赖于HotModuleReplacementPlugin,或者 entry加入'webpack-dev-server/client?http://0.0.0.0:3104' hotOnly: true, // 或者entry加入[''webpack/hot/only-dev-server'','webpack/hot/poll?1000'] watchOptions: { ignored: /node_modules/, }, // 配置console.log信息输出 noInfo: false, clientLogLevel: 'warning', // 不在浏览器console中输出热加载信息 stats: { // copied from `'minimal'` all: false, modules: true, maxModules: 0, errors: true, warnings: true, // our additional options colors: true, timings: true, moduleTrace: true, errorDetails: true, assets: false, }, }, }); } else { config = merge(base, { optimization: { minimizer: [ new TerserJSPlugin({ test: /\\.(js|jsx)(\\?.*)?$/i, exclude: [path.resolve(__dirname, '../node_modules')], parallel: 4, terserOptions: { compress: { pure_funcs: ['console.info', 'console.debug', 'console.warn'] } } }), new OptimizeCssAssetsPlugin({ cssProcessor: require('cssnano'), cssProcessorOptions: { discardComments: { removeAll: true } }, canPrint: true, }), ], splitChunks: { cacheGroups: { verdor: { test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all' }, styles: { name: 'styles', test: /\\.css$/, chunks: 'all', enforce: true, priority: 10, }, }, }, }, plugins: [ new MiniCssExtractPlugin({ filename: isDev ? '[name].css' : '[name].[hash:8].css', chunkFilename: isDev ? '[name].chunk.css' : '[name].[hash:8].chunk.css', }), ], stats: 'errors-only', }); } return config; }; 根据上述的思路，进行逐一分析 出现问题的是 production and js文件 webpack里面 Module rules 匹配的js| jsx 文件并没有对 Mode 不同做出不同的处理，因此排除 ... { test: /\\.css$/, use: [ isDev ? 'style-loader' : MiniCssExtractPlugin.loader, { loader: 'css-loader', options: { sourceMap: true, }, }, ], }, ... 这个规则虽然有针对不同mode去做特殊处理，但并不是针对js文件来的，因此也排除掉 less 和 css 的规则大致相同，因此也排除掉 继续往下看，会发现有个比较有意思的地方 ... if (isDev) { config = merge(base, { module: { rules: [ // 前端页面性能监控 { test: require.resolve('react-addons-perf'), use: [{ loader: 'expose-loader', options: 'Perf', }], }, ], }, plugins: [ new webpack.HotModuleReplacementPlugin(), // 当接收到热更新信号时，在浏览器console控制台打印更多可读性高的模块名称等信息 new webpack.NamedModulesPlugin(), ], devServer: { compress: true, open: false, host: '0.0.0.0', port: 3011, index: 'src/index.html', publicPath: '/', historyApiFallback: true, // 设为false会导致手动刷新页面（路由有效）时，报404 // 配置热加载,所有配置替代方案：webpack-cli --inline --hot --hot-only inline: true, // 实时刷新 // 注意，必须有 webpack.HotModuleReplacementPlugin 才能完全启用 HMR。如果 webpack 或 webpack-dev-server 是通过 --hot 选项启动的，那么这个插件会被自动添加，所以你可能不需要把它添加到 webpack.config.js 中。 hot: true, // 模块热更新。依赖于HotModuleReplacementPlugin,或者 entry加入'webpack-dev-server/client?http://0.0.0.0:3104' hotOnly: true, // 或者entry加入[''webpack/hot/only-dev-server'','webpack/hot/poll?1000'] watchOptions: { ignored: /node_modules/, }, // 配置console.log信息输出 noInfo: false, clientLogLevel: 'warning', // 不在浏览器console中输出热加载信息 stats: { // copied from `'minimal'` all: false, modules: true, maxModules: 0, errors: true, warnings: true, // our additional options colors: true, timings: true, moduleTrace: true, errorDetails: true, assets: false, }, }, }); } else { config = merge(base, { optimization: { minimizer: [ new TerserJSPlugin({ test: /\\.(js|jsx)(\\?.*)?$/i, exclude: [path.resolve(__dirname, '../node_modules')], parallel: 4, terserOptions: { compress: { pure_funcs: ['console.info', 'console.debug', 'console.warn'] } } }), new OptimizeCssAssetsPlugin({ cssProcessor: require('cssnano'), cssProcessorOptions: { discardComments: { removeAll: true } }, canPrint: true, }), ], splitChunks: { cacheGroups: { verdor: { test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all' }, styles: { name: 'styles', test: /\\.css$/, chunks: 'all', enforce: true, priority: 10, }, }, }, }, ... 由于问题出现在production模式下，因此我们只需关系 else里面的逻辑即可 config = merge(base, { optimization: { minimizer: [ new TerserJSPlugin({ }), new OptimizeCssAssetsPlugin({ cssProcessor: require('cssnano'), cssProcessorOptions: { discardComments: { removeAll: true } }, canPrint: true, }), ], splitChunks: { cacheGroups: { verdor: { test: /[\\\\/]node_modules[\\\\/]/, name: 'vendors', chunks: 'all' }, styles: { name: 'styles', test: /\\.css$/, chunks: 'all', enforce: true, priority: 10, }, }, }, }, plugins: [ new MiniCssExtractPlugin({ filename: isDev ? '[name].css' : '[name].[hash:8].css', chunkFilename: isDev ? '[name].chunk.css' : '[name].[hash:8].chunk.css', }), ], stats: 'errors-only', }); 根据对插件的大概了解，会发现webpack在打包时进行了优化(压缩一下) webpack优化参数 有兴趣的可以去了解一下，webpack如何进行优化处理 一个压缩Js插件 引起了我的注意。terset-webpack-plugin 根据上述具体分析得出：异常是 mode = production and js ，那么刚好这个terset插件只有在mode = production 并且用来处理js文件的。通过查看package.json文件，并没有找到这个插件，但通过yarn.lock文件，发现了安装webpack4版本时，一同安装了这个插件。 ","link":"https://a1733452028.github.io/post/webpack-da-bao-yi-chang-pai-cha-si-lu/"},{"title":"webpack工程化","content":"迁移原因 由于roadhogrc封装的webpack版本太旧，不适合用于现代组件的打包，因此会在引用高版本的组件时出现语法错误等原因，最终导致打包失败(严重影响项目的正常运行) 1、如何运行webpack 在迁移之前需要弄懂如何通过简答的webpack来运行项目 安装webpack时，最好使用最高版本的node.js来安装 webpack-cli: 命令行工具(webpack5 可以不需要了) yarn add webapck, webapck-cli 2、文件目录结构 config ：存放webpack的配置文件 src ：存放业务逻辑文件 package.json：记录依赖包的版本号 生产环境下 通过对比，会发现新增了一个文件.babelrc .babelrc 文件主要是配置babel-loader的参数 { &quot;presets&quot;: [ [ &quot;@babel/preset-env&quot;, { &quot;useBuiltIns&quot;: false, &quot;modules&quot;: false } ], &quot;@babel/preset-react&quot; ], &quot;plugins&quot;: [ [ &quot;@babel/plugin-transform-runtime&quot;, { &quot;corejs&quot;: 3 } ], &quot;@babel/plugin-transform-modules-commonjs&quot;, &quot;@babel/plugin-syntax-dynamic-import&quot;, [ &quot;babel-plugin-import&quot;, { &quot;libraryName&quot;: &quot;antd&quot;, &quot;libraryDirectory&quot;: &quot;es&quot;, &quot;style&quot;: true } ], &quot;inline-react-svg&quot;, &quot;@babel/plugin-transform-reserved-words&quot;, &quot;@babel/plugin-proposal-export-default-from&quot;, &quot;@babel/plugin-proposal-nullish-coalescing-operator&quot;, &quot;@babel/plugin-proposal-optional-chaining&quot;, [&quot;@babel/plugin-proposal-decorators&quot;,{ &quot;legacy&quot;: true }], &quot;@babel/plugin-proposal-class-properties&quot; ] } 3、webpack 基本配置 Resolve: 这些选项能设置模块如何被解析。webpack 提供合理的默认值，但是还是可能会修改一些解析的细节。关于 resolver 具体如何工作的更多解释说明，请查看模块解析 Resolve.extensions 尝试按顺序解析这些后缀名。如果有多个文件有相同的名字，但后缀名不同，webpack 会解析列在数组首位的后缀的文件 并跳过其余的后缀。 asset/resource 发送一个单独的文件并导出 URL。之前通过使用 file-loader 实现。 css-loader 主要是解析css文件中的@import和url语句，处理css-modules，并将结果作为一个js模块返回。通俗的来说：会处理import/require() @import/url 引入的内容 重点: css-loader处理之后，返回的是数组，页面无法实现数组 // 假如我们有a.css、b.css、c.css // a.css @import './b.css'; // 导入b.css .a { font-size: 16px; } // b.css @import './c.css'; // 导入c.css .b { color: red; } // c.css .c { font-weight: bolder; } // 可以理解为css-loader将a.css、b.css和c.css的样式内容以字符串的形式拼接在一起，并将其作为js模块的导出内容。 // css-loader源码（经简化） // https://github.com/webpack-contrib/css-loader/blob/master/src/index.js import postcss from 'postcss'; module.exports = async function (content, map, meta) { const options = this.getOptions(); // 获取配置 const plugins = []; // 转译源码所需的postcss插件 shouldUseModulesPlugins(options, this) &amp;&amp; plugins.push(modulesPlugins); // 处理css-modules shouldUseImportPlugin(options, this) &amp;&amp; plugins.push(importPlugin); // 处理@import语句 shouldUseURLPlugin(options, this) &amp;&amp; plugins.push(urlPlugin); // 处理url()语句 shouldUseIcssPlugin(options, this) &amp;&amp; plugins.push(icssPlugin); // 处理icss相关逻辑 if (meta &amp;&amp; meta.ast) { // 复用前面loader生成的CSS AST（如postcss-loader） content = meta.ast.root; } const result = await postcss(plugins).process(content); // 使用postcss转译源码 const importCode = getImportCode(); // 需要导入的依赖语句 const moduleCode = getModuleCode(result); // 模块导出内容 const exportCode = getExportCode(); // 其他需要导出的信息，如css-modules的类名映射等 const callback = this.async(); // 异步返回 callback(null, `${importCode}${moduleCode}${exportCode}`); }; style-loader 经过css-loader的转译，我们已经得到了完整的css样式代码，style-loader的作用就是将结果以style标签的方式插入DOM树中。通俗来说：css-loader 解析后的内容挂载到html页面中。 因此：需要搭配css-loader使用 // 但css-loader返回的不是css样式代码的文本，而是一个js模块的代码，将这些js代码直接放进style标里显然是不行的。 // style-loader import loaderUtils from 'loader-utils'; module.exports = function (content) { // do nothing }; module.exports.pitch = function (remainingRequest) { /* * 用require语句获取css-loader返回的js模块的导出 * 用'!!'前缀跳过配置中的loader，避免重复执行 * 用remainingRequest参数获取loader链的剩余部分，在本例中是css-loader、less-loader * 用loaderUtils的stringifyRequest方法将request语句中的绝对路径转为相对路径 */ const requestPath = loaderUtils.stringifyRequest(this, '!!' + remainingRequest); // 本例中requestPath为: // '!!../node_modules/css-loader/index.js!../node_modules/less-loader/dist/cjs.js!src/styles/index.less' return ` const content = require(${requestPath}) const style = document.createElement('style'); style.innerHTML = content; document.head.appendChild(style); `; }; less-loader **Less**是CSS预处理语言，扩展了CSS语言，增加了变量、Mixin、函数等特性，Less-loader的作用就是将less代码转译为浏览器可以识别的CSS代码。 // demo.less @base: #f938ab; .box-shadow(@style, @c) when (iscolor(@c)) { -webkit-box-shadow: @style @c; box-shadow: @style @c; } .box-shadow(@style, @alpha: 50%) when (isnumber(@alpha)) { .box-shadow(@style, rgba(0, 0, 0, @alpha)); } .box { color: saturate(@base, 5%); border-color: lighten(@base, 30%); div { .box-shadow(0 0 5px, 30%) } } // 上面的less代码会被less-loader编译成 // demo.css .box { color: #fe33ac; border-color: #fdcdea; } .box div { -webkit-box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); box-shadow: 0 0 5px rgba(0, 0, 0, 0.3); } // less-loader 原理： // less-loader实现（经简化） const less = require('less'); module.exports = function(content) { const callback = this.async(); // 转译比较耗时，采用异步方式 const options = this.getOptions(); // 获取配置文件中less-loader的options less.render( content, createOptions(options), // less转译的配置 (err, output) =&gt; { callback(err, output.css); // 将生成的css代码传递给下一个loader } ); }; webpack.commont.js module.exports = { // 入口 entry: { index: './src/index.js', }, // 输出 output: { filename: '[name].bundle.js' || '[name].[contenthash].bundle.js', path: paths.appDist, // publicPath: paths.appPublic, // 编译前清除目录 clean: true }, resolve: { extensions: ['.tsx', '.jsx', '.ts', '.js'], }, plugins: [ // 生成html，自动引入所有bundle new HtmlWebpackPlugin({ title: 'release_v1', }), // 进度条 new ProgressBarPlugin({ format:' :msg [:bar] :percent (:elapsed s)' }), ], module: { rules: [ { test: /\\.(png|svg|jpg|jpeg|gif)$/i, include: [ paths.appSrc, ], type: 'asset/resource', }, { test: /.(woff|woff2|eot|ttf|otf)$/i, include: [ paths.appSrc, ], type: 'asset/resource', }, { test: /\\.css$/, include: paths.appSrc, use: [ // 将 JS 字符串生成为 style 节点 'style-loader', // 将 CSS 转化成 CommonJS 模块 'css-loader', ], }, { test: /.(scss|sass)$/, include: paths.appSrc, use: [ // 将 JS 字符串生成为 style 节点 'style-loader', // 将 CSS 转化成 CommonJS 模块 'css-loader', // 将 Sass 编译成 CSS 'sass-loader', ], }, { test: /\\.module\\.(scss|sass)$/, include: paths.appSrc, use: [ // 将 JS 字符串生成为 style 节点 'style-loader', // 将 CSS 转化成 CommonJS 模块 { loader: 'css-loader', options: { // Enable CSS Modules features modules: true, importLoaders: 2, // 0 =&gt; no loaders (default); // 1 =&gt; postcss-loader; // 2 =&gt; postcss-loader, sass-loader }, }, // 将 PostCSS 编译成 CSS { loader: 'postcss-loader', options: { postcssOptions: { plugins: [ [ // postcss-preset-env 包含 autoprefixer 'postcss-preset-env', ], ], }, }, }, // 将 Sass 编译成 CSS 'sass-loader', ], }, { test: /\\.(js|ts|jsx|tsx)$/, include: paths.appSrc, use: [ { loader: 'esbuild-loader', options: { loader: 'tsx', target: 'es2015', }, } ] } ], }, } Webpack.dev.js module.exports = merge(common, { // 模式 mode: 'development', // 开发工具，开启 source map，编译调试 devtool: 'eval-cheap-module-source-map', // 开发模式，自动更新改动 devServer: { static: './dist', }, }) devtool 中的cheap-module“不包含列信息，源码是开发时的代码”;eval&quot;生成代码和Source Map 内容混淆在一起&quot; mode webpack 环境配置 一般只使用'Development'和'Production'(简称 开发环境 和 生产环境) devtool 配置 推荐 开发环境 ： eval-cheap-module-source-map 生产环境： nosources-source-map 或者 source-map 使用上述的配置，即可运行项目 webpack-dev-server -config config/webpack.dev.js -open devServer.static 该配置项允许配置从目录提供静态文件的选项（默认是 'public' 文件夹）。将其设置为 false 以禁用。简单的来理解，devServer读取的静态文件都是从当前的./dist文件来读取的 4、蓝天项目 roadhogrc 迁移至 webpack5 注意事项 以开发环境为例子 webpack.commont.js文件改造成 const HtmlWebpackPlugin = require('html-webpack-plugin'); const ProgressBarPlugin = require('progress-bar-webpack-plugin'); const CopyWebpackPlugin = require('copy-webpack-plugin'); const paths = require('./paths'); const lessToJs = require('less-vars-to-js'); const fs = require('fs'); const paletteLess = fs.readFileSync(paths.resolveApp('src/styles/variables.less'), 'utf8'); const lessVars = lessToJs(paletteLess, { resolveVariables: true, stripPrefix: true }); module.exports = { target: ['web', 'es5'], context: paths.appContext, // 入口 entry: { index: './src/index.js', }, // 输出 output: { filename: '[name].js', path: paths.appDist, publicPath: '/', chunkFilename: '[name].chunk.js', // publicPath: paths.appPublic, // 编译前清除目录 // clean: true, pathinfo: false }, resolve: { extensions: ['.tsx', '.jsx', '.ts', '.js', '.json'], fallback: { fs: false, stream: false, path: false, crypto: false }, modules: [ paths.appSrc, paths.appNodeModules, paths.appNodeModulesResolveOwn, 'node_modules' ], symlinks: false, alias: { Utils: paths.appUtils, '@babel/runtime': '@babel/runtime-corejs2', }, }, plugins: [ // 生成html，自动引入所有bundle new HtmlWebpackPlugin({ // favicon: paths.appLogo, title: '蓝天系统', mountRoot: 'root', template: paths.appHtml, filename: 'index.html', inject: 'body', htmlContent: '&lt;%- __html__ %&gt;', initialData: 'window.__INITIAL_STATE__ = &lt;%- __state__ %&gt;', hash: true, // 为静态资源生成hash值 minify: { // 压缩HTML文件 removeComments: false, // 移除HTML中的注释 collapseWhitespace: false, // 删除空白符与换行符 }, }), // 进度条 new ProgressBarPlugin({ format: ' :msg [:bar] :percent (:elapsed s)' }), new CopyWebpackPlugin({ patterns: [ { from: paths.appPublic, to: 'public', toType: 'dir' }, ] }), ], module: { rules: [ { test: /\\.(js|ts|jsx)$/, include: paths.appSrc, exclude: paths.appNodeModules, use: [ { loader: 'thread-loader', options: { workers: 10 } }, { loader: 'babel-loader?cacheDirectory', }, ] }, { test: /\\.(png|jpg|jpeg|gif)$/i, include: paths.appSrc, exclude: paths.appNodeModules, type: 'asset/resource', use: { loader: 'url-loader', options: { limit: 1024 * 10, outputPath: 'images' } } }, { test: /.(woff|woff2|eot|ttf|otf)$/i, include: paths.appSrc, exclude: paths.appNodeModules, type: 'asset/resource', }, { test: /\\.css$/, use: [ { loader: 'style-loader', }, { loader: 'css-loader', options: { sourceMap: true, } }, ], }, { test: /\\.js\\.map$/, use: { loader: 'file-loader' }, }, { test: /\\.less$/, include: /[\\\\/]node_modules[\\\\/].*antd/, use: [ { loader: 'style-loader' }, { loader: 'css-loader', options: { sourceMap: true, }, }, { loader: 'less-loader', options: { sourceMap: true, lessOptions: { javascriptEnabled: true, math: 'always', modifyVars: { ...lessVars, }, } }, }, ], }, { test: /\\.less$/, include: paths.appSrc, exclude: paths.appNodeModules, use: [ { loader: 'style-loader', }, { loader: 'css-loader', options: { modules: { localIdentName: '[name]__[local]' }, importLoaders: 2, }, }, { loader: 'less-loader', options: { implementation: require.resolve('less'), sourceMap: true, lessOptions: { javascriptEnabled: true, modifyVars: lessVars, }, }, }, ], }, { test: /.(scss|sass)$/, include: paths.appSrc, exclude: paths.appNodeModules, use: [ // 将 JS 字符串生成为 style 节点 'style-loader', // 将 CSS 转化成 CommonJS 模块 'css-loader', // 将 Sass 编译成 CSS 'sass-loader', ], }, { test: /\\.(png|jpg|gif)$/, exclude: paths.appNodeModules, use: [ { loader: 'file-loader', options: { name: '[path][name].[ext]', outputPath: 'images/', } } ] }, { test: /\\.svg$/, include: paths.appSrc, use: [ { loader: 'url-loader', options: { name: '[name].[ext]', outputPath: 'images/', } } ], exclude: paths.appNodeModules, }, { test: /\\.module\\.(scss|sass)$/, exclude: paths.appNodeModules, include: paths.appSrc, use: [ // 将 JS 字符串生成为 style 节点 'style-loader', // 将 CSS 转化成 CommonJS 模块 { loader: 'css-loader', options: { // Enable CSS Modules features modules: true, importLoaders: 2, // 0 =&gt; no loaders (default); // 1 =&gt; postcss-loader; // 2 =&gt; postcss-loader, sass-loader }, }, // 将 PostCSS 编译成 CSS { loader: 'postcss-loader', options: { postcssOptions: { plugins: [ [ // postcss-preset-env 包含 autoprefixer 'postcss-preset-env', ], ], }, }, }, // 将 Sass 编译成 CSS 'sass-loader', ], }, ], }, }; 新增一个文件paths.js const fs = require('fs') const path = require('path') const appDirectory = process.cwd(); const resolveApp = relativePath =&gt; path.resolve(appDirectory, relativePath); function resolveOwn (relative) { return path.resolve(__dirname, '.', relative); } module.exports = { resolveApp, appPublic: resolveApp('public'), appHtml: resolveApp('src/index.html'), appSrc: resolveApp('src'), appDist: resolveApp('dist'), appNodeModules: resolveApp(&quot;node_modules&quot;), appTsConfig: resolveApp('tsconfig.json'), appContext: resolveApp(&quot;./&quot;), appUtils: resolveApp(&quot;src/utils&quot;), appNodeModulesResolveOwn: resolveOwn(&quot;node_modules&quot;), appLogo: resolveApp(&quot;public/fonts/svg/logo.svg&quot;) } websocket.dev.js const { merge } = require('webpack-merge'); const paths = require('./paths'); const common = require('./webpack.common'); const TerserPlugin = require('terser-webpack-plugin'); // const SpeedMeasurePlugin = require('speed-measure-webpack-plugin'); // const smp = new SpeedMeasurePlugin(); module.exports = merge(common, { // 开启缓存 cache: { type: 'filesystem' }, // 模式 mode: 'development', // 开发工具，开启 source map，编译调试 devtool: 'eval-cheap-module-source-map', plugins: [ // new BundleAnalyzerPlugin() ], // 开发模式，自动更新改动 devServer: { port: 3010, historyApiFallback: true, // 设为false会导致手动刷新页面（路由有效）时，报404 compress: true, // gzip 压缩 hot: 'only', // 启用热模块替换功能，在构建失败时不刷新页面作为回退，使用 hot: 'only' proxy: { '/api': { target: 'https://devnbas.gz4399.com/', changeOrigin: true, } }, setupExitSignals: true, //允许在 SIGINT 和 SIGTERM 信号时关闭开发服务器和退出进程 }, optimization: { minimize: true, minimizer: [ new TerserPlugin({ test: /\\.(jsx|js)$/, extractComments: true, parallel: true, }), ], splitChunks: { cacheGroups: { styles: { name: 'styles', test: /\\.css$/, chunks: 'all', enforce: true, priority: 10, }, }, }, }, }); 可能会遇到的问题 1、ERROR in ./node_modules/dva-core/lib/Plugin.js 13:43-89 ERROR in ./node_modules/dva-core/lib/Plugin.js 13:43-89 Module not found: Error: Package path ./core-js/get-iterator is not exported from package /Users/liangpingbo/Desktop/4399/frontend/nbas_frontend/node_modules/@babel/runtime (see exports field in /Users/liangpingbo/Desktop/4399/frontend/nbas_frontend/node_modules/@babel/runtime/package.json) @ ./node_modules/dva-core/lib/index.js 28:38-57 @ ./node_modules/dva-core/index.js 1:0-33 @ ./node_modules/dva/lib/index.js 96:15-34 @ ./node_modules/dva/index.js 5:0-34 @ ./src/index.js 13:34-48 解决办法： @babel/runtime 使用别的模块(@babel/runtime-corejs2)来 解析 在webpack的reslove解析函数中找到alias把@babel/runtime 添加进去 2、Inline JavaScript is not enabled. Is it set in your options? .bezierEasingMixin(); ^ Inline JavaScript is not enabled. Is it set in your options? Error in /Users/liangpingbo/Desktop/4399/frontend/nbas_frontend/node_modules/antd/es/style/color/bezierEasing.less (line 110, column 0) @ ./node_modules/antd/es/input-number/style/index.less 8:6-188 22:17-24 26:7-21 58:25-39 59:36-47 59:50-64 63:6-73:7 64:54-65 64:68-82 70:42-53 70:56-70 72:21-28 83:0-158 83:0-158 84:22-29 84:33-47 84:50-64 61:4-74:5 @ ./node_modules/antd/es/input-number/style/index.js 2:0-22 @ ./src/routes/Devops/Log/QueryForm.jsx 99:0-37 @ ./src/routes/Devops/index.js 156:13-38 @ ./src/routes/BasicLayout.jsx 167:13-31 @ ./src/routes/index.js 27:42-66 @ ./src/index.js 89:11-41 解决方法：通过设置less-loader的options来解决 打开注释lessOptions中的 javascriptEnabled:true即可解决 less 行内联样式的问题 3、Error evaluating function unit: the first argument to unit must be a number. Have you forgotten parenthesis? &amp;.@{select-tree-prefix-cls}-switcher_open { .antTreeSwitcherIcon(); ^ Error evaluating function `unit`: the first argument to unit must be a number. Have you forgotten parenthesis? Error in /Users/liangpingbo/Desktop/4399/frontend/nbas_frontend/node_modules/antd/es/tree-select/style/index.less (line 93, column 10) @ ./node_modules/antd/es/tree-select/style/index.less 8:6-188 22:17-24 26:7-21 58:25-39 59:36-47 59:50-64 63:6-73:7 64:54-65 64:68-82 70:42-53 70:56-70 72:21-28 83:0-158 83:0-158 84:22-29 84:33-47 84:50-64 61:4-74:5 @ ./node_modules/antd/es/tree-select/style/index.js 2:0-22 @ ./src/routes/Cmdb/UserAdd.jsx 49:0-36 @ ./src/routes/Cmdb/UserList.jsx 45:38-58 @ ./src/routes/Cmdb/index.js 113:13-33 @ ./src/routes/BasicLayout.jsx 140:13-29 @ ./src/routes/index.js 27:42-66 @ ./src/index.js 89:11-41 Unit 解析失败，unit 用于计算 的, 而目前@select-tree-prefix-cls 是一个变量。 解决方案：忽略计算先。less-loader.options.lessoptions.math = &quot;always&quot;(扩展 parens | strict 代表所有数学表达式都需要括号) 4、ERROR in ./public/service.png 1:0 Module parse failed: Unexpected character '�' (1:0) ERROR in ./public/service.png 1:0 Module parse failed: Unexpected character '�' (1:0) You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders (Source code omitted for this binary file) @ ./src/routes/components/Support/index.js 79:38-79 @ ./src/routes/components/Footer.jsx 19:38-58 @ ./src/routes/BasicLayout.jsx 79:37-67 @ ./src/routes/index.js 27:42-66 @ ./src/index.js 89:11-41 问题分析：根据错误提示指出 png文件出现了无法解析的字符�，你可能需要一个解析器来处理 解决思路：通过添加file-loader解析来处理png, jpg, gif等文件 5、ERROR in ./public/fonts/svg/箭头.svg 1:0 Module parse failed: Unexpected token (1:0) You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. ERROR in ./public/fonts/svg/箭头.svg 1:0 Module parse failed: Unexpected token (1:0) You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders <?xml version=\"1.0\" standalone=\"no\"?><!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"> @ ./src/routes/DataBase/Examine/Query/CreateRightCardAce.jsx 87:33-92 @ ./src/routes/DataBase/Examine/Query/CreateRightCard.jsx 41:49-80 @ ./src/routes/DataBase/Examine/Query/Create.jsx 55:46-74 @ ./src/routes/DataBase/Examine/index.jsx 108:13-37 90:13-37 @ ./src/routes/DataBase/index.js 128:13-32 @ ./src/routes/BasicLayout.jsx 164:13-33 @ ./src/routes/index.js 27:42-66 @ ./src/index.js 89:11-41 问题分析：根据错误路径分析 错误都是出现在 jsx或者js文件中，而解析js 或者 jsx时都会使用babel-loader。而定义babel-loader解析器都是在.babelrc文件中。错误内容是无法解析svg的内容，因此需要一款svg的解析器 解决办法： plugins 插件中 安装 inline-react-svg来解决 6、export 'Route' (imported as 'Route') was not found in '../../components/Route' (module has no exports) WARNING in ./src/routes/Ywops/Webssh/index.js 59:46-51 export 'Route' (imported as 'Route') was not found in '../../components/Route' (module has no exports) @ ./src/routes/Ywops/index.js 231:13-31 @ ./src/routes/BasicLayout.jsx 100:13-30 @ ./src/routes/index.js 7:0-40 31:46-57 41:15-26 @ ./src/index.js 75:11-41 问题分析：错误路径发生在.js 文件中，因此看babel-loader的配置；错误内容相对路径导入有问题。 解决办法：引入@babel/plugin-transform-modules-commonjs 来解决 7、process is not defined core.js Core.js 的路径 是 /node_modules/vfile/core.js Uncaught (in promise) ReferenceError: process is not defined at new VFile (:4010/vendors-node_modules_react-markdown_lib_react-markdown_js.chunk.js:8073) at VFile (:4010/vendors-node_modules_react-markdown_lib_react-markdown_js.chunk.js:8067) at Function.parse (:4010/vendors-node_modules_react-markdown_lib_react-markdown_js.chunk.js:7553) at ReactMarkdown (:4010/vendors-node_modules_react-markdown_lib_react-markdown_js.chunk.js:6721) at renderWithHooks (index.js:204994) at mountIndeterminateComponent (index.js:207076) at beginWork (index.js:207681) at performUnitOfWork (index.js:211368) at workLoop (index.js:211408) at renderRoot (index.js:211491) 因此解决办法是： 单独对core.js的文件更换解析器来解决 { test: /node_modules(\\/|\\\\)vfile(\\/|\\\\)core\\.js/, use: [{ loader: 'imports-loader', options: { type: 'commonjs', imports: ['single process/browser process'], }, }], }, 5、未完待续 以后若遇到其他的问题，我会继续补充上~ ","link":"https://a1733452028.github.io/post/webpack-gong-cheng-hua/"},{"title":"antV G6可视化的探索","content":"01 摘要 图数据库领域时最近几年大数据领域热度颇高的领域，自2013年开始，图数据库的发展就一起绝尘。与传统关系数据库不同，图数据技术主要关注数据间关系查询能力，是表示和查询关联关系的最佳方式。AntV 团队在图数据库领域沉浸多年，因此本文主要结合的AntV的框架在实际项目中的实践阐述图可视化技术在图数据库领域的应用。 02 背景简介 随着移动互联网的普及及5G时代的到来，数据库的数据量将会越来越多。面对海量数据，尤其是非结构化数据的存储，传统的关系型数据库已经无法满足分析的需求，分布式图数据库能够很清晰地揭示各类复杂关系，尤其是针对错综复杂的业务逻辑，其优势更为明显。 2.1 应用场景 图数据库的发展和大数据的发展有着密切的联系。大数据之所以受到广泛关注，其本质在于对海量数据的统计、汇总、分析，可以从中发现一些隐含的规律。 以真实项目(数据库主从拓扑)为例，其主体是数据库实例。数据库实例之间可能存在主从关系，主主关系。通过图数据库展示时，整个数据拓扑关系会一目了然。 当数据库主从关系过多，靠人工对数据进行一一排列时会容易出现问题，甚至会梳理错误。在很多场景中，相比于数据本身，其实我们更加关注数据背后所表达的一些信息，以及信息之间的关联。图数据库模式能够更加直观，自然的展示这种关联，对于用户来说，和数据的交互方式，使用数据的方式，通过图的方式也要更加直接。 目前，我们在真实的项目有两个场景使用AntV G6开源可视化引擎进行开发。一是数据库主从关系拓扑，另外一个是机柜分析 以数据库主从关系拓扑为例，用户可以通过搜搜索机房或者平台来筛选，不同机房或者不同平台之间存在哪些数据库实例主从关系。也可以通过把鼠标放到数据库实例上查看，当前数据库实例的主机相关信息及实际的基本信息。 通过机房视角来区分，当前不同机房是有哪些数据实例 通过上图，还可以清晰地查看到XXX机房里面的哪个数据库实例和XXX机房里面具体的那个数据库实例是主从关系的。通过箭头也可以清晰的区分出来，主从关系(有箭头则代表从机)，主主关系(双箭头) 点击某个具体实例，能查看主机的基本情况，例如 MasterHost ,MasterPort等等信息 其中，机柜分析可以对整个机房网络拓扑结构，流量，终端设备等接入进行可视化管理（基于cmdb数据进行绘制） 通过左键某个交换机即可查看当前机柜的服务器存放的位置和连接状态。 通过上面的具体实例，是不是顿时对可视化领域感兴趣呢？接下来，就跟着小编的步伐带你了解可视化技术的知识。 03 问题分析 当在图数据库领域运用可视化技术，通常会遇到两类问题： 数据建模：传统的建模方式是通过填写表单来创建点边，这种方案存在的问题是建模效率低以及无法直观地看清楚图模型的关联关系，如何提升建模效率及直观地展示图模型中的关系时我们需要重点解决的问题。 数据分析： 图数据库的查询结果默认返回的是点边集合，一般情况下会使用文本或表格的形式展示，这种方式最大的问题是无法洞察数据之间的关系及发现数据中蕴含的特征，如何有效地提升探索分析的效率及发现关联关系数据中蕴含的特征，是图探索分析需要解决的最大问题。 04 解决方案 针对上述提出的两个问题，得出如下的解决方案： 可视化建模 图探索分析 4.1 可视化建模 传统的图模型创建的方式是通过填写表单来生成点边，可视化建模有别于传统的方式。通过可视化拖拽的方式来完成点边的创建，可以有效提升建模的效率，并让提高了模型的可读性。可视化建模方案主要包括图模型的创建、管理及交互三个方面。 4.1.1 创建模型 图模型是由点边组成的，图模型的创建也就是创建具体的点和边。图模型的创建可采用可视化拖拽加表单填充两种交互形态相互结合的方式完成： 可视化操作提供全局预览、快速创建关联的能力 表单填充主要关注节点\\边的属性信息，降低属性填入操作复杂度 4.1.2 可视化管理 创建完模型以后，加载模型后，可以以可视化的形式来展示和管理。可视化管理模型核心是一块画布。画布之上除会提供诸如搜索、放大缩小、全屏等常见交互能力，还须具备通过拖拽进行模型操作的能力。 用户点击图中节点/边会在右下角浮出一个预览面板，用户可以通过该面板快速预览节点和边详情。同时用户若有编辑面板的需求可以通过此面板的编辑按钮快速进入编辑弹窗。用户还可以通过节点/边的右键菜单，选择点/边的快速删除以及快捷数据导入。 4.1.3 提高模型的可读性 模型的可读性无论是对于数据运维同学还是数据开发同学都是至关重要。一个清晰美观模型能够帮助我们快速解读当前模型，是提升效率的前置条件。如何提高模型的可读性呢？我们可以通过模型的设计规范，布局规范，交互规范来解决。 4.1.3.1 设计规范 在图数据库领域，不同场景图模型承载的信息有很大差异，所以设计规范主要考虑的是其通用性。主要通过颜色，大小，Label，状态四种元素进行区分； 针对目前数据库主从关系拓扑图来说，颜色主要倾向于蓝色；大小一般使用30； Label是由服务器(ip)+业务名称+机房来组成的；状态则使用Img的数据库图片。 4.1.3.2 布局规范 模型中点边数量通常会控制在100以内，但是不同场景会有较大的差异。所以在布局层面主要以力导布局为主；也可以根据模型特征选用同心圆布局，网格布局，辐射布局等；由于数据库主从关系拓扑需要以某个机房，某个业务等及某个机房为视角，因此布局使用dagre+Combo的流程图较为合适。 4.1.3.3 交互规范 对于可读性而言，用到的点边交互有选中、hover、拖拽、右键；以及放大缩小、适配、布局定位等全局交互能力；通常图中也无法呈现点/边上的所有属性，需要通过增加属性面板/Tooltip的方式来进行属性呈现。 4.2 图搜索分析 图搜索分析，也是从查询开始，但有别于传统数据库管理系统的查询，图探索分析中的查询是用户通过输入一段DSL、选择一个算法模板或路径开始执行查询，得到并将查询结果渲染到画布上后，以后的分析步骤是没有明确目的的，绝大部分时间都是在探索节点之间的关联关系，试图从数据的关系中发现有价值的洞察。 完整的图搜索分析应用由以下部分组成： 全局工具栏：用来承载保存/导出/前进后退等全局操作 查询面板：进行数据的查询，包括点边查询、DSL(Gremlin、Cypher)、算法查询 渲染区：对数据库查询结果进行查询。同时具备一定的交互性，允许用户查看节点的详细信息，对节点进行二次探索，算法分析等交互操作 控制面板：针对渲染区中可视化的内容进行全局操作，如切换布局、切换节点样式、全屏、放大/缩小等 统计面板：展示全局统计信息 预览面板：呈现节点和边的完整属性信息 其他：根据数据类型，可支持TimeBar,地图等额外的模块 4.3 画布绘制 图的可读性主要可以体现在合适的场景采用合适的布局策略、善于使用图元素的视觉元素表达不同信息和排除图中干扰元素。 4.2.1 合适的场景采用合适的布局策略 合适的场景采用合适的布局策略，必要时可以采用多种布局策略结合（子图布局）提升图的可读性。如下图可以描述的是围绕一个叫Peter的人展开的探索，可以清晰得到Peter在一个叫Nashville的地方度过的大学。 4.2.2 善用节点/边视觉元素表达不同的信息 善用节点/边视觉元表达不同的信息。 4.2.3 排除图中干扰因素 必要时候可以通过过滤面板、节点显隐、节点折叠、关联高亮、关键路径高亮等手段排除图中干扰因素，使数据更聚集。 4.3 交互探索 4.3.1 下钻式的探索 下钻式的探索是针对有聚合节点的情况，用户针对聚合节点可以进行展开操作，展开的操作中，如果还存在聚合节点，可以继续展开操作。 用户选定一个节点，使用双击、右击菜单等形式指定展开一个聚合节点。展开该聚合节点即获取所有被聚类到该聚合节点中的下一层次的节点，将这些节点与当前图上其余部分进行混合，得到的图我们成为混合图。 展示混合图，由图可视化开源与分析引擎AntV G6完成，主要包括： 节点和边的绘制：节点和边的样式要符合图可视化视觉规范； 布局：由于展开聚合节点是当前图的一个增量改变过程，没有被改变的部分应当尽可能被保留在原来的布局位置上，新增的节点需要重新计算布局位置，并使用特殊的标识表明，方便用户快速定位新增内容。 4.3.2 元素信息探索 元素信息探索，主要包括查看节点、边、聚合节点或聚合边的详情信息 用户点选画布上的节点或边时，被点选的元素将会被高亮，并出现一个元素详情面板，展示该元素的详细信息： 若被点选的元素是聚合节点/聚合边，详情面板中将展示聚合节点/聚合边中所含有的真实节点； 若被点选的元素是真实节点/真实边，详情面板中奖展示该节点/边的具体数据属性。 4.3.3 画布探索 画布探索，主要通过画布上的ToolBar来实现的，我们可以对画布进行缩放、可以使用拉缩选择多个元素、也可以使用鱼眼放大镜等。 对画布的探索，可能的操作如下： 用户可以切换不同的工具对画布进行探索，例如放大、缩小画布； 使用拉缩进行多个元素的圈选； 使用鱼眼放大镜探索图上元素密集的部分； 对图上节点/边进行筛选； 05 未来展望 AntV G6 引擎如此强大，能应用的场景还远远未挖掘完全。我们将会使用AntV G6针对云安全进行可视化处理。安全可视化是一个交叉研究领域，通过提供交互式可视化工具，提升安全分析人员感知、分析和理解网络安全问题的能力。 针对服务器上存在的日志，以及后端数据之后，最终呈现出来的效果如下： 后记 小编在AntV G6的应用上，还有很长的路需要走。希望下次和大家再次见面时能够带来不一样的G6 视觉盛宴，未完待续。。。 ","link":"https://a1733452028.github.io/post/antv-g6-ke-shi-hua-de-tan-suo/"},{"title":"问题联想功能的进阶实现","content":"简单的问题联想可以通过mysql的rlike like 或者elasticsearch进行搜索 这里我要讲述另一个不同的方式来实现(通过前缀树来实现) class Trie: def __init__(self): self.lookup={} #字典树的每个节点是一个dict dict的key是字符 dict的val是一个全新的dict def insert(self,word): tree=self.lookup for i in word: if i not in tree: tree[i]={} tree=tree[i] tree[&quot;$&quot;]=None #单词的结束标志 val什么值都可以 关键search/startsWith关注的是&quot;$&quot;这个key def search(self,word,flag=False): tree=self.lookup for i in word: if not i in tree: return False tree=tree[i] if flag or &quot;$&quot; in tree: return True return False def startsWith(self,prefix): return self.search(prefix,True) #鉴于startsWith和search的高度相似性 所以直接调search ","link":"https://a1733452028.github.io/post/wen-ti-lian-xiang-gong-neng-de-jin-jie-shi-xian/"},{"title":"有序列表的插入你真的懂了吗？","content":"bisect 在python标准库有个bisect模块是内置模块，实现了一个算法用于插入元素到有序列表中。在某一些情况下，这比反复排序列表或者构造一个大的列表在排序的效率更高. import bisect L = [1,3,3,6,8,12,15] x = 3 x_insert_point = bisect.bisect_left(L, x) # 在 L 中查找 x，x 存在时返回 x 左侧的位置，x 不存在返回应该插入的位置 # 这是3存在于列表中，返回左侧位置１ print(x_insert_point) x_insert_point = bisect.bisect_right(L, x) # 在 L 中查找 x，x 存在时返回x右侧的位置，x 不存在返回应该插入的位置 # 这是3存在于列表中，返回右侧位置３ print(x_insert_point) x_insort_left = bisect.insort_left(L, x) #将 x 插入到列表 L 中，x 存在时插入在左侧 print(L) x_insort_rigth = bisect.insort_right(L, x) #将 x 插入到列表L中，x 存在时插入在右侧 print(L) ","link":"https://a1733452028.github.io/post/you-xu-lie-biao-de-cha-ru-ni-zhen-de-dong-liao-ma/"},{"title":"文件 X模式你懂了吗？","content":"假如有一个需求：写一个文件，如果该文件已经存在，则不写。实现方式也很简单，我们先判断一下文件是否存在，如果已经存在，则打印提示信息并跳过，否则，我们就用w模式打开文件 常规的写法： import os if not os.path.exists('somefile'): with open('somefile', 'wt') as f: f.write('Hello\\n') else: print 'File alreay exists!' 简洁的写法：直接使用x模式来判断就可了 with open('somefile', 'xt') as f: f.write('Hello\\n') ","link":"https://a1733452028.github.io/post/wen-jian-x-mo-shi-ni-dong-liao-ma/"},{"title":"Kafka中遇到的问题","content":"1、使用NewAsyncProducer 异步生产者时，若配置是以下 configv1 := sarama.NewConfig() configv1.Producer.RequiredAcks = sarama.WaitForLocal configv1.Producer.Return.Successes = true // 发送成功后，需要消费否则会阻塞 具体原因： // Successes is the success output channel back to the user when Return.Successes is // enabled. If Return.Successes is true, you MUST read from this channel or the // Producer will deadlock. It is suggested that you send and read messages // together in a single select statement. Successes() &lt;-chan *ProducerMessage // Errors is the error output channel back to the user. You MUST read from this // channel or the Producer will deadlock when the channel is full. Alternatively, // you can set Producer.Return.Errors in your config to false, which prevents // errors to be returned. Errors() &lt;-chan *ProducerError 如果开启了Return.Successes = true,频道会以死锁的状态一直卡恰在 2、开启kakfa断线重连机制 configv1 := sarama.NewConfig() configv1.Metadata.Retry.Max = 3 configv1.Metadata.Retry.Backoff = time.Second * 1 3、开启异步消费者请求超时 configv1 := sarama.NewConfig() ","link":"https://a1733452028.github.io/post/kafka-zhong-yu-dao-de-wen-ti/"},{"title":"飞书小程序开发中遇到的坑(ios白屏问题)","content":"以下结论，是通过实践的出来部分原因(具体原因待完善以及挖掘) ### 小程序页面生命周期概述 在小程序页面打开时会有相应的生命周期函数回调，它们包括onLoad，onShow，onReady，onHide，onUnload。小程序开发者可根据需要在不同的合适的生命周期回调函数中实现自己的页面逻辑。下图为每个生命周期函数的触发时机示意图： ### 小程序生命周期概述 App(params) 是框架启动小程序的入口函数, 开发者可以通过 App(params) 的参数指定小程序的生命周期函数和其他一些自定义参数 ### 小程序api接口概述 小程序提供了多种 API 来暴露客户端能力，如获取用户信息、本地存储等功能，分为两种：同步、异步。其中异步 API 通过回调返回结果，同步 API 直接返回结果。(简单来说, 有success,fail回调函数都认为是异步调用) 通过对以上三个概念分析得出一个结论 小程序加载过程： app.onShow -&gt; page.OnReady 但经过实践可以得出在app.js onShow生命周期时请求异步login接口，在page的onLoad, onShow都无法获取到，想要获取userInfo的内容，只能在page的onReady生命周期上获取。 通俗来说就是，在app 的onShow上登录login并设置到globalData上，在page onReady上请求userInfo并生成web-view的url url组成是固定前缀&quot;https://devfeishu-support.gz4399.com/main?&quot;+两个动态参数code(login success返回的)和nickname(userInfo success返回)组成的 这样部署生命周期的好处是：当用户将飞书小程序切换到后台模式时不会重新请求页面，即可以完美保留历史记录，若需关闭页面(ios只能通过杀飞书后台，无法单独杀程序;android可以单独杀后台，但有个问题是：杀完后台后，不能立马请求页面。立马请求会出现访问白屏的问题，个人猜测是飞书小程序并没有即时清理cache导致的) ","link":"https://a1733452028.github.io/post/fei-shu-xiao-cheng-xu-kai-fa-zhong-yu-dao-de-keng-ios-bai-ping-wen-ti/"},{"title":"如何开发智能客服系统","content":"如何开发智能客服系统 前言 ​ 在线客服系统是一种网页版即时通讯软件的统称。主要能实现对其他通信软件无缝衔接(小编这里主要是指飞书和其他各大内部系统)，为网站以及其他的应用提供和访客对话的平台。 准备工作 ​ ”so easy 嘛！需求文档, 拿来吧你~“ “需求图给你，接好~” 这个需求文档好像长得不太对劲？？？ 没办法了，那只能靠个人想象发挥了~ 正所谓“人靠衣装马靠鞍”，好看的UI框架是必不可少的。身为忠实阿里巴巴粉丝，始终坚信阿里巴巴出品必属精品！ 最终我选择由阿里巴巴出品的chatUI (能满足项目中基本需求)作为我的前端UI组件，而后端则选择Go语言中Web框架gin 需求探讨 显然根据上文展示的需求文档进行一系列开发是不太现实的，这时就需要我们站起来和需求方进行深入交流(交流过程省略1万字。。。。自行脑补) 最终得出的需求有以下几点 机器人对话FQA(一问一答的方式) 用户问题联想功能 在线人工服务 知识库浏览功能 业务工单系统 会话历史查询 机器人FQA基本流程图 1、机器人对话FQA(一问一答的方式) ​ 机器人对话FQA是什么呢？frequently asked questions的缩写，通俗的叫法“常见问题解答”。可以列出一些用户常见的问题，是一种在线帮助形式。 功能分析 1、表明机器人可以做什么 2、猜你想了解的 3、输入文字则返回相应的数据 功能1（表明机器人可以做什么？） ​ 实现起来超简单的，只要后端返回当前登录用户，以及登录时间，简述机器人的作用即可。这里不过多描述 功能2（猜你想了解） ​ 根据需求分析，得到以下效果。 用户所在场景分为两大类别： 飞书客户端(工作台)以及google谷歌浏览器 公司内部系统嵌套 大致流程如下： 首先判断用户登录的地方，若是飞书登录。查询用户是否当天咨询过，如果咨询过则优先返回咨询过的数据，返回的数据条数不足10条，查询热门问题；否则 直接查询热门问题。若热门问题+咨询过的问题不足10条，则随机取；取到10条为止。 用户咨询过的行为用户clickhouse表引擎MergeTree进行记录(用户行为不能修改，只用于添加和查询，因此为了降低MySQL的压力，使用clickhouse是最合适的选择) ​ 猜你想了解流程图 掀起袖子，开始撸代码 // 1. 查询用户是否当天咨询过 ymd := fmt.Sprintf(&quot;%s-%s-%s 00:00:00&quot;, time.Now().Year(), time.Now().Month(), time.Now().Day()) stamp, _ := time.ParseInLocation(&quot;2006-01-02 15:04:05&quot;, ymd, time.Local) rows, _ := config.G_clickhouse.Query(fmt.Sprintf(&quot;select content, count(content) As content_num from support_message where user_id = %d and create_time &gt; toDateTime(%d) group by content order by content_num desc;&quot;, util.Int(checkExist[&quot;id&quot;]), util.Int(stamp.Unix()))) recommendList := make([]map[string]interface{}, 0) existsList := make([]string, 0) for rows.Next(){ // 如果recommendList的长度等于10就退出 if len(recommendList) == 10{ return } var ( content string content_num int ) if err := rows.Scan(&amp;content, &amp;content_num);err !=nil{ Self.Write_resp(c,1, &quot;clickhouse查询失败&quot;, &quot;&quot;) return } recommendList = append(recommendList, map[string]interface{}{ &quot;title&quot;: content, }) existsList = append(existsList, content) } // 1.1 如果当前的recommendList已经等于10，则不需要做任何操作 if len(recommendList) &lt; 10{ // 1.2 如果当前的recommendList小于10，则有两个逻辑(1.追加当天热门问题且不重复的 2.随机不重复的问题) // 1.2.1 追加当天热门不重复问题 hots,_ := config.G_clickhouse.Query(fmt.Sprintf(&quot;select content, count(content) As content_num from support_message where create_time &gt; toDateTime(%d) group by content order by content_num desc;&quot;, util.Int(stamp.Unix()))) for hots.Next(){ ... 执行追加逻辑 } // 1.2.2 如果追加了当天热门不重复问题长度依然没有到长度10，则随机不重复问题了 if len(recommendList) &lt; 10{ // 随机获取推荐的10条信息 ... 在mysql中获取10条随机不重复的数据 } } 通过一系列操作之后，实现的效果如图所示： ​ 效果图 数据优先级： 用户咨询过的 ----- 热门类型 ---- 随机 功能3（输入文本返回相应的数据） ​ 用户输入某个大概词语或者关键字，输出对应的关键词。 由于小编这里快捷短语，联想输入和用户输入都是同一由前端send函数调用，因此没有对动作行为进行区分开。若要达到较好的用户体验，则需要对思路进行梳理。 具体实现思路： 具体的代码就不放出来，代码量较多。。 2、用户问题联想功能（关键词自动补全 ，自动纠正） 作为资深google搜索的用户，常常感叹google的问题联想是怎么实现的？怎么这么牛逼的呢 经过多次查询资料后得出，实现类似功能。可以通过使用elasticsearch中的建议器(completion suggester)进行实现。 于是掀起袖子，开始撸代码啦~~~~ 首先创建索引名为support_konwledege_index PUT http://xxx.xxx.xxx.xxx/support_konwledege_index/ { &quot;settings&quot;: { &quot;number_of_shards&quot;: &quot;1&quot;, &quot;index.refresh_interval&quot;: &quot;15s&quot;, &quot;index&quot;: { &quot;analysis&quot;: { &quot;analyzer&quot;: { &quot;default&quot;: { &quot;tokenizer&quot;: &quot;ik_max_word&quot; }, &quot;pinyin_analyzer&quot;: { &quot;tokenizer&quot;: &quot;shopmall_pinyin&quot; }, &quot;first_py_letter_analyzer&quot;: { &quot;tokenizer&quot;: &quot;first_py_letter&quot; }, &quot;full_pinyin_letter_analyzer&quot;: { &quot;tokenizer&quot;: &quot;full_pinyin_letter&quot; }, &quot;ik_pinyin_analyzer&quot;:{ &quot;tokenizer&quot;:&quot;ik_smart&quot; } }, &quot;tokenizer&quot;: { &quot;shopmall_pinyin&quot;: ... 语法分析器根据索引进行配置即可, &quot;first_py_letter&quot;: ... 同上, &quot;full_pinyin_letter&quot;: { &quot;type&quot;: &quot;pinyin&quot;, &quot;keep_separate_first_letter&quot;: false, &quot;keep_full_pinyin&quot;: false, &quot;keep_original&quot;: false, &quot;limit_first_letter_length&quot;: 16, &quot;lowercase&quot;: true, &quot;keep_first_letter&quot;: false, &quot;keep_none_chinese_in_first_letter&quot;: false, &quot;none_chinese_pinyin_tokenize&quot;: false, &quot;keep_none_chinese&quot;: true, &quot;keep_joined_full_pinyin&quot;: true, &quot;keep_none_chinese_in_joined_full_pinyin&quot;: true } } } } } } index.refresh_interval 执行刷新操作的频率，这使得索引的最近更改对搜索可见。默认为1s. 可以设置-1为禁用刷新。如果未明确设置此设置，则至少index.search.idle.after几秒钟内未看到搜索流量的分片将不会收到后台刷新，直到它们收到搜索请求。命中空闲分片的搜索将等待下一次后台刷新（在 内1s）。此行为旨在在不执行搜索的默认情况下自动优化批量索引。为了选择退出此行为，1s应将的显式值设置为刷新间隔。(由于数据不需要那么实时更新和缓解后台压力，因此设置15s是完全够的) 定义Ik分词器以及pinyin分词器 完成以上操作，索引已经创建完成了，剩下需要创建map映射了 PUT http://xxx.xxx.xxx.xxx/support_konwledege_index/_mapping/konwledege_type?include_type_name=true { &quot;properties&quot;: { &quot;title&quot;: { &quot;type&quot;: &quot;completion&quot;, &quot;fields&quot;: { &quot;pinyin&quot;: { &quot;type&quot;: &quot;completion&quot;, &quot;analyzer&quot;: &quot;pinyin_analyzer&quot;, &quot;preserve_separators&quot;: false }, &quot;keyword_pinyin&quot;: ...(配置可以到网上进行查询) &quot;keyword_first_py&quot;: ...(配置可以到网上进行查询) &quot;my_pinyin&quot;:{ &quot;type&quot;:&quot;completion&quot;, &quot;analyzer&quot;: &quot;ik_pinyin_analyzer&quot;, &quot;preserve_separators&quot;: false } } } } } preserve_separators 保留分隔符，默认为true. 如果禁用，您可以找到一个以 开头的字段Foo Fighters。可以通过foof 查找，一般这里设置成false即可。 完成上面的操作后，索引，map都创建好了，只需导入数据即可。 接下来对elasticsearch进行搜索，看代码： GET http://xxx.xxx.xxx.xxx/support_konwledege_index/konwledege_type/_search?pretty { &quot;_source&quot;: &quot;title&quot;, &quot;suggest&quot;: { &quot;match&quot;: { &quot;text&quot;: &quot;什么事&quot;, &quot;completion&quot;: { &quot;field&quot;: &quot;title&quot;, &quot;size&quot;: 5, &quot;fuzzy&quot;: { &quot;fuzziness&quot;: &quot;AUTO&quot;, &quot;min_length&quot;: 3, &quot;prefix_length&quot;: 2, &quot;unicode_aware&quot;: true } // &quot;skip_duplicates&quot;:true } } } } 结果： { &quot;took&quot;: 6, &quot;timed_out&quot;: false, &quot;_shards&quot;:..., &quot;hits&quot;: ..., &quot;suggest&quot;: { &quot;match&quot;: [ { &quot;text&quot;: &quot;什么事&quot;, &quot;offset&quot;: 0, &quot;length&quot;: 3, &quot;options&quot;: [ { &quot;text&quot;: &quot;什么是回源HOST&quot;, &quot;_index&quot;: &quot;support_konwledege_index&quot;, &quot;_type&quot;: &quot;konwledege_type&quot;, &quot;_id&quot;: &quot;31&quot;, &quot;_score&quot;: 2.0, &quot;_source&quot;: { &quot;title&quot;: { &quot;input&quot;: &quot;什么是回源HOST&quot;, &quot;weight&quot;: 2 } } }, ... ] } ] } } 为什么我输入“什么事”，会搜索到”什么是XXX“这种标题呢？原因是fuzzy这个字段，elasticsearch官网中的解析是The completion suggester also supports fuzzy queries — this means you can have a typo in your search and still get results back. 简单的描述就是支持模糊查询，在搜索中输入拼写错误，但仍然可以返回结果。 具体参数： fuzziness The fuzziness factor, defaults to AUTO. See Fuzziness for allowed settings. transpositions if set to true, transpositions are counted as one change instead of two, defaults to true min_length Minimum length of the input before fuzzy suggestions are returned, defaults 3 prefix_length Minimum length of the input, which is not checked for fuzzy alternatives, defaults to 1 unicode_aware If true, all measurements (like fuzzy edit distance, transpositions, and lengths) are measured in Unicode code points instead of in bytes. This is slightly slower than raw bytes, so it is set to false by default. 图上代码主要设置了模糊因子为自动, fuzziness: Auto; min_length: 3, prefix_length：2 , unicode_aware: true unicode_aware: 这个对字符进行Unicode 转换，由于我们大多数是中文，需要Unicode 编码的，否则min_length 和 prefix_length 的长度计算都不是以Unicode编码计算的。 ​ 可能你也发现了_score评分参数和weight 是一样的~，是的。我对内容进行weight权重的控制，实现热门问题置顶的效果。(suggets默认搜索结果排序是按照数字大小、字母ASCII码、input索引到ES的顺序排序) 根据上面的代码来进行操作已经完成了核心的功能，我们就往细节进行优化了~ 1、当用户输入关键词后，没有找到文章内容，相关问题应该返回热门问题，文章内容需要返回没有找到内容的语术。 2、当用户输入关键词后，找到文章内容，但没有找到类似的问题(类似问题的寻找规律是关键词的长度 除以 2 形成新的关键词), 相关问题需要返回热门问题 3、当用户输入关键词后，找到文章内容，权重需要发生变化 4、用户多次搜索同一个标题，标题权重只会加1次 3、在线人工服务 当机器人没有返回用户满意的答案时，人工接入称为解决用户问题的最终手段。 想要实现较好的人工服务，必须有一个较好的架构服务。经过多方考量，得出人工服务架构如下： 人工服务使用web端即时通讯技术，实现即时通讯方法在市面上普遍有4中方法 1、轮询 2、长轮询(comet) 3、长连接 4、websocket 具体的优缺点，我在此就不一一分析。项目中采用的是websocket协议进行通信的。 1.既然采用websocket协议，所以需要对原有的http协议进行升级改造(这里使用github.com/gorilla/websocket) // 升级get请求为websocket协议 ws, err := upGrader.Upgrade(c.Writer, c.Request, nil) if err != nil { return } client := &amp;Client{Conn: ws, Send: make(chan []byte, 256), UserInfo: nil} 2.订阅协程kafka消费者 go client.Consumer() func (c *Client) Consumer() { consumer, err := sarama.NewConsumer(config.GlobalConfig.Support.Kafka.Host, nil) if err != nil { logs.Error(&quot;kafka 失败&quot;, err) return } // 程序运行结束时，调用Close关闭消费者对象 defer func() { if err := consumer.Close(); err != nil { log.Printf(&quot;消费者关闭&quot;) return } }() fmt.Printf(&quot;====================开启消费者通道：%s===================== \\n&quot;, c.UserInfo.OpenId) // 创建消费者对象管理的分区消费者对象 partitionConsumer, err := consumer.ConsumePartition(c.UserInfo.OpenId, 0, sarama.OffsetNewest) if err != nil { logs.Error(&quot;kafka创建分区失败&quot;, err) } defer func() { if err := partitionConsumer.Close(); err != nil { log.Println(err) } }() for message := range partitionConsumer.Messages() { res := map[string]interface{}{} json.Unmarshal(message.Value, &amp;res) c.Conn.WriteJSON(res) } } 根据上面代码，可以理解成每个用户都是一个信箱，每当有消息来的时候，需要对用户的信箱进行写入(这就是写扩散，因为小助手群聊人数一般不会超过5个人，因此写扩散带来的性能问题可以忽略不计，但逻辑却可以带来极大便利) 一套消息转发就这样简单实现了~接下来对消息类型进行不同逻辑处理(如下图所示) 消息类型分为8大类型 ping cmd session_all file callback calc_session text image ping 类型的消息 用于前端维护websocket的心跳机制，前端发送ping的内容，若后端接收到ping消息会返回前端pong消息，若前端没有接收到后端返回的pong消息，则会采用阶梯式发送ping 消息。阶梯式档位一般分为(30s 1分钟 5分钟 直接断开) cmd 类型的消息 用于系统类型消息。我这里用于退出会话(主要因为小助手是属于客服对话，用户咨询完，会话不必显示在当前列表中，会话状态设置为关闭) session_all 类型的消息 用于用户或者管理员点开新的会话，从而获取当前会话的所有聊天记录(由于会话不会一直不变和聊天内容不会很多，所以不需要采用分页的形式) file 类型的消息 用于用户或管理员发送文件消息(消息里面有url, size, name) callback 类型的消息 用于管理员或者用户不小心发送错了消息，可以有撤回的机会 calc_session 类型的消息 用于实时计算会话列表，用于有新的消息到来，会话置顶。未读消息，未读计数+1等等 text 类型的消息 用于管理员或用户 发送文字 image 类型的消息 用于用户或者管理员发送图片消息(消息里面有url, size, name) 根据上面的架构以及分析，是时候撸代码了 func (c *Client) Read() { defer func() { c.Conn.Close() }() for { _, message, err := c.Conn.ReadMessage() if err != nil { if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) { log.Printf(&quot;error : %v&quot;, err) } break } messageHandler := util.MapStr(message) if messageHandler[&quot;type&quot;] == &quot;ping&quot; { // 向kafka中发送消息 Producer(c.UserInfo.OpenId, map[string]interface{}{ &quot;type&quot;: &quot;pong&quot;, }) } else if messageHandler[&quot;type&quot;] == &quot;cmd&quot; { if util.MapStr(messageHandler[&quot;content&quot;])[&quot;code&quot;] == &quot;sub&quot; { c.GetGroupList() } else if util.MapStr(messageHandler[&quot;content&quot;])[&quot;code&quot;] == &quot;agent_leave&quot; { c.AgentLeave(messageHandler) } } else if messageHandler[&quot;type&quot;] == &quot;session_all&quot; { c.GetSessionMsg(messageHandler) } else if messageHandler[&quot;type&quot;] == &quot;callback&quot; { c.CallBackMsg(messageHandler) } else if messageHandler[&quot;type&quot;] == &quot;calc_session&quot; { c.GetSessionList() } else { c.SendMsg(messageHandler) } } } 以上就是运维小助手后端设计方案以及核心思路。 功能4,5,6都属于普普通通的web开发功能，我就不一一讲解啦。 最后带大家来康康成品后的效果叭~ 用户界面： 管理员界面： 后记 市面上有很多优秀的开源客服系统，但定位都各有千秋。市面上的开源客服系统不能一一满足我们的需求。复杂的定制逻辑以及应用场景都需要定制开发，但是受到产品本身的语言或者框架的局限性，导致使用困难，维护成本较高，折腾半天发现还不如自己弄一个。在线客服系统我们已经向前迈进了一步。后面的路怎么走，或许还需要更多的探索。 ","link":"https://a1733452028.github.io/post/ru-zhu-gridea/"}]}